#!/usr/bin/env python

import rospy
import sys, os
import std_msgs.msg
import geometry_msgs.msg

from sensor_msgs.msg import LaserScan
from math import sin,cos,atan2,pi,sqrt
import matplotlib.pyplot as plt

from ellipse2d import Ellipse2d

fig=plt.figure()
#subscribe to laserscan
class Tracker:
    def __init__(self):
	#declare base_room here so it only has to be called once
	base = open(os.path.dirname(os.path.abspath(sys.argv[0]))+"/base_room.txt")
	self.base_room = [[float(string) for string in line.strip().split(',')] for line in base]
	base.close()

    #turn laser range into xy, remove walls
    def fit_ellipse(self, data):
    	ellipse_xy = []
    	points = [] #array to hold all points - FOR DEBUGGING
    	offset = 0.05 #distance for being considered part of wall, in meters. Make variable later.
    	angle = data.angle_min
    	incr = data.angle_increment
    	ranges = data.ranges
    	#polar >> cartesian
    	for r in ranges:
	    coordinate = [cos(angle)*r, sin(angle)*r] #make xy
	    #if dots aren't part of walls add them to the list
	    if all((abs(coordinate[0]-b[0]) > offset) or (abs(coordinate[1]-b[1]) > offset) for b in self.base_room):
		ellipse_xy.append(coordinate)
	    angle+=incr
	    points.append(coordinate) # - FOR DEBUGGING
	#fit ellipse to  points
	#e2 = Ellipse2d()
    	#e2.fit(ellipse_xy)
	#DEBUGGER: display ellipse relative to wall data
    	#print e2.a, e2.b, e2.theta, e2.center
    	#e2.plot()
    	x = points[:][0]
    	y = points[:][1]
    	plt.scatter(x,y, c='b') #walls are blue
    	ex = ellipse_xy[:][0]
    	ey = ellipse_xy[:][1]
    	plt.scatter(x,y, c='k') #ellipse points are black
    	self.fig.canvas.draw()

    def tracker(self):
    	rospy.init_node("tracker", anonymous=True)
    	#listen to scan topic
    	rospy.Subscriber("scan", LaserScan, self.fit_ellipse)
    	#spin until node is closed
    	rospy.spin()

if __name__ == '__main__':
    t = Tracker()
    try:
        t.tracker()
    except rospy.ROSInterruptException:
        pass
